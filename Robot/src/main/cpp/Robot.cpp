// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "Robot.h"

#include <frc/Commands/Scheduler.h>
#include <frc/SmartDashboard/SmartDashboard.h>

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INITIALIZATION
std::shared_ptr<DriveSubSystem> Robot::driveSubSystem;
std::shared_ptr<LiftSubSystem> Robot::liftSubSystem;
std::shared_ptr<HatchSubSystem> Robot::hatchSubSystem;
std::unique_ptr<OI> Robot::oi;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INITIALIZATION

std::shared_ptr<NetworkTable> Robot::visionNetworkTable;

// Xbox controller(s)
std::unique_ptr<ControllerState> Robot::controllerState1;
std::unique_ptr<ControllerState> Robot::controllerState2;

// Command groups
std::unique_ptr<Teleop> Robot::teleop;

// lift control mode flag
LiftMode Robot::liftMode = LiftMode::Disabled;

// hatch ejection system status flag
HatchEjectMode Robot::hatchMode = HatchEjectMode::PortNotInRange;

////////////////////////////////////////
// Methods

void Robot::RobotInit() 
{
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    driveSubSystem.reset(new DriveSubSystem());
    liftSubSystem.reset(new LiftSubSystem());
    hatchSubSystem.reset(new HatchSubSystem());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
	// This MUST be here. If the OI creates Commands (which it very likely
	// will), constructing it during the construction of CommandBase (from
	// which commands extend), subsystems are not guaranteed to be
	// yet. Thus, their requires() statements may grab null pointers. Bad
	// news. Don't move it.
	oi.reset(new OI());

    // initialize the Xbox controller

	// Add commands to Autonomous Sendable Chooser
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS



    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS
//	frc::SmartDashboard::PutData("Auto Modes", &chooser);

	Robot::visionNetworkTable = nt::NetworkTableInstance::GetDefault().GetTable("limelight");

	//These controller states are used instead of OI
	this->controllerState1.reset(new ControllerState(0));  //1st xbox controller for driving
	this->controllerState2.reset(new ControllerState(1));  //2nd xbox controller for driving
}

/**
 * This function is called when the disabled button is hit.
 * You can use it to reset subsystems before shutting down.
 */
void Robot::DisabledInit()
{

}

void Robot::DisabledPeriodic() 
{
	frc::Scheduler::GetInstance()->Run();
}

void Robot::AutonomousInit() 
{
	// 'un-press' all buttons - button states are saved from last teleop run
	// unless the robot is disconnected from drive station
	this->controllerState1->InitializeButtonStates();
	this->controllerState2->InitializeButtonStates();

	// add the teleop commands to the scheduler and start the loop
    this->teleop.reset(new(Teleop));
    this->teleop->Start();
}

void Robot::AutonomousPeriodic() 
{
    this->controllerState1->GetState();
    this->controllerState2->GetState();
	frc::Scheduler::GetInstance()->Run();
}

void Robot::TeleopInit() 
{
	// This makes sure that the autonomous stops running when
	// teleop starts running. If you want the autonomous to
	// continue until interrupted by another command, remove
	// these lines or comment it out.


	// 'un-press' all buttons - button states are saved from last teleop run
	// unless the robot is disconnected from drive station
	// this->controllerState1->InitializeButtonStates();
	// this->controllerState2->InitializeButtonStates();

	// add the teleop commands to the scheduler and start the loop
    // this->teleop.reset(new(Teleop));
    // this->teleop->Start();

		// 'un-press' all buttons - button states are saved from last teleop run
	// unless the robot is disconnected from drive station
	this->controllerState1->InitializeButtonStates();
	this->controllerState2->InitializeButtonStates();

	// add the teleop commands to the scheduler and start the loop
    this->teleop.reset(new(Teleop));
    this->teleop->Start();
 }

void Robot::TeleopPeriodic() 
{
    this->controllerState1->GetState();
    this->controllerState2->GetState();
	frc::Scheduler::GetInstance()->Run();
}

void Robot::TestPeriodic()
{
	printf("ta = %4.3f\n", Robot::visionNetworkTable->GetNumber("ta", 0.0));
}

////////////////////////////////////////////////////////////////
#ifndef RUNNING_FRC_TESTS
int main(int argc, char** argv)
{
    return frc::StartRobot<Robot>();
}
#endif
