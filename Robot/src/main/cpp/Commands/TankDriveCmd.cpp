// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "Commands/TankDriveCmd.h"
#include <cmath>


bool TankDriveCmd::autoAlignParallel = false;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

TankDriveCmd::TankDriveCmd(): frc::Command() {
        // Use requires() here to declare subsystem dependencies
    // eg. requires(Robot::chassis.get());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	Requires(Robot::driveSubSystem.get());
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
}
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

// Called just before this Command runs the first time
void TankDriveCmd::Initialize()
{
    // initialize our local accessors
    driveSubSystem = Robot::driveSubSystem.get();
    controllerState = Robot::controllerState1.get();
	SetSpeedScale(1.0);	//TODO program in control system!!!
	Robot::hatchMode = HatchEjectMode::PortNotInRange;
	this->autoAlignPerpendicular = false;
	this->autoAlignParallel = false;

	// Limelight angle, area, in-range, skew
	this->tx = 0;
	this->ta = 0;
	this->tv = 0;
	this->ts = 0;

	// enable the software PID controller
	printf("Tank drive command initialized\n");
}

// Called repeatedly when this Command is scheduled to run
void TankDriveCmd::Execute()
{
	// get vision parameters for closed loop control
	this->tx = Robot::visionNetworkTable->GetNumber("tx", 0.0);
	this->tv = Robot::visionNetworkTable->GetNumber("tv", 0.0);
	this->ta = Robot::visionNetworkTable->GetNumber("ta", 0.0);

	// if we have a target in sight...
	if (this->tv == 1.0)
	{
		// rumble the controller to alert the driver that we're close...
		double rumble = (std::abs(this->tx) < this->angleTolerance) ? .5 : .9;
		Robot::controllerState1->m_controller.SetRumble(
            frc::GenericHID::RumbleType::kLeftRumble, rumble);

		// auto alignment driver assist
		AutoAlignParallelFromLimelight();
		AutoAlignPerpendicularFromLimelight();
	}
	else
	{
		// turn off the controller rumble
		Robot::controllerState1->m_controller.SetRumble(
            frc::GenericHID::RumbleType::kLeftRumble, 0.0);
	}
	

	if (this->autoAlignPerpendicular)
	{
		return; // we are lining up to pickup or place a hatch
	}

	if (this->autoAlignParallel)
	{
		return;	// we are lining up to pickup or place a hatch
	}

	// get raw joystick values and +- sign
	//this pulls the joystick values into the program.
	//(gets the state) gets what you want to do
	float leftX = -this->controllerState->GetLeftY();
	float rightX = -this->controllerState->GetRightY();

	// compute the adjusted motor values based n joystick / motor curve
	//this takes the value and matches it with the closest value on our parabola
	//so that the driving is smoother
	float leftY = SignOf(leftX) * SmoothDriveCurve(fabsf(leftX));
	float rightY = SignOf(rightX) * SmoothDriveCurve(fabsf(rightX));
    
	//Code used for inverting driving direction. 
	//This is not used in the 2019 season as it was deemed not necessary.
	// if (this->controllerState->GetButtonA()) // Invert drive code
	// {
	// 	float temp = leftY;
	// 	leftY = rightY;
	// 	rightY = temp;
	// }

	//Old code for toggle of the slowmode. Changed for the 2019 season to be a trigger to be held rather than a toggle
	// if (this->controllerState->GetButtonB()) 
	// {
	// 	this->SetSpeedScale(.25); // 'slow' mode for motors
	// }
	// else
	// {
	// 	this->SetSpeedScale(1.0);
	// }

	if (this->controllerState->GetRightTrig() > 0.4) //Triggers return float value -- when pressed > threshold trigger.
	{
		this->SetSpeedScale(1.0); //'fast'mode when trigger pressed.
	} 
	else 
	{
		this->SetSpeedScale(0.5); //'slow' mode by default.
	}

    this->driveSubSystem->SetLeftSpeed((double)leftY);
    this->driveSubSystem->SetRightSpeed((double)rightY);
}

// Make this return true when this Command no longer needs to run execute()
bool TankDriveCmd::IsFinished()
{
    return false;
}

// Called once after isFinished returns true
void TankDriveCmd::End()
{

}

// Called when another command which requires one or more of the same
// subsystems is scheduled to run
void TankDriveCmd::Interrupted()
{

}

double TankDriveCmd::SmoothDriveCurve(double joystickYPosition) const
{
	if (joystickYPosition < .05)
	{
		return 0.0;		// allow for joystick calibration error
	}

	// data points on drive curve parabola
	//double x2 = .62, y2 = .36, y3 = 1.0;
	double x2 = .5, y2 = .5, y3 = 1.0;

	// variable a=a in equation b=b in equation
	//ax^2+bx+c the Equation for a parabola
	double b = ((y3 * x2 * x2) - y2) / ((x2 * x2) - x2);
	double a = y3 - b;

	// Returns the corresponding motor speed
	double motorSpeed = (a * joystickYPosition * joystickYPosition) + (b * joystickYPosition);
	return fabs(motorSpeed * this->motorSpeedScale);
}

void TankDriveCmd::AutoAlignPerpendicularFromLimelight()
{
	// bail if controller is in parallel auto-align mode...
	if (Robot::controllerState1->m_controller.GetRawButton(BUTTON_Y))
	{
		return;
	}

	// bail if controller isn't in perpendicular auto-align mode...
	if (!Robot::controllerState1->m_controller.GetRawButton(BUTTON_A))
	{
		if (this->autoAlignPerpendicular)
		{
			// we are at the target, turn off the motors and increase the rumble
			this->driveSubSystem->SetLeftSpeed(0.0);
    		this->driveSubSystem->SetRightSpeed(0.0);
		}

		this->autoAlignPerpendicular = false;
		return;
	}

	// bail if we are not close to a target...
	if (this->tv  != 1.0 || Equals(std::abs(this->ts), 45.0, 5.0))
	{
		if (this->autoAlignPerpendicular)
		{
			// we are out of range, turn off the motors
			this->driveSubSystem->SetLeftSpeed(0.0);
    		this->driveSubSystem->SetRightSpeed(0.0);
		}

		this->autoAlignPerpendicular = false;
	}

    // get horizontal angle to target
 	double leftSpeed = -Robot::controllerState1->GetLeftY() * 0.40; 
	double rightSpeed = leftSpeed;
	double cosAngle = cos(degreeToRadian * this->tx); 
	
	if (!Equals(std::abs(this->tx), 0.0, this->angleTolerance))
	{
		if (this->tx > 0.0)
		{
			// turn right
			rightSpeed = leftSpeed - (autoAlignGain * (1.0 - cosAngle));
		}
		else
		{
			// turn left, if the initial angle is less than 90 degrees
			rightSpeed = leftSpeed  + (autoAlignGain * (1.0 - cosAngle));
		}
	}

	if (rightSpeed > 1.0)
	{
		rightSpeed = 1.0;
	}

	if (rightSpeed < 0.0)
	{
		rightSpeed = 0.0;
	}

	// output for debugging
	// printf("tx = %4.3f  leftSpeed = %4.3f rightSpeed = %4.3f\n",
	//  tx, leftSpeed, rightSpeed);
	 
	this->driveSubSystem->SetLeftSpeed(leftSpeed);
    this->driveSubSystem->SetRightSpeed(-rightSpeed);
	this->driveSubSystem->Periodic();
}

void TankDriveCmd::AutoAlignParallelFromLimelight()
{
	// bail if controller is in perpendicular auto-align mode...
	if (Robot::controllerState1->m_controller.GetRawButton(BUTTON_A))
	{
		return;
	}
	
	// bail if controller isn't in parallel auto-align mode...
	if (!Robot::controllerState1->m_controller.GetRawButton(BUTTON_Y))
	{
		if (this->autoAlignParallel)
		{
			// we are at the target, turn off the motors and increase the rumble
			this->driveSubSystem->SetLeftSpeed(0.0);
    		this->driveSubSystem->SetRightSpeed(0.0);
		}

		this->autoAlignParallel = false;
		return;
	}

	// bail if we are not close to a target...
	if (this->tv  != 1.0)
	{
		if (this->autoAlignParallel)
		{
			// we are out of range, turn off the motors
			this->driveSubSystem->SetSetpointRelative(0.0);
		}	

		this->autoAlignParallel = false;
	}

    // get horizontal angle to target, and set motor speed for both sides
	double sinAngle = sin(degreeToRadian * this->tx); 
	double motorSpeed = -sinAngle * this->parallelGain;

	if (motorSpeed > 1.0)
	{
		motorSpeed = 1.0;
	}

	if (motorSpeed < -1.0)
	{
		motorSpeed = -1.0;
	}

	// output for debugging
	// printf("tx = %4.3f  motorSpeed = %4.3f\n",
	// tx, motorSpeed);

	this->driveSubSystem->SetLeftSpeed(motorSpeed);
    this->driveSubSystem->SetRightSpeed(-motorSpeed);
	this->driveSubSystem->Periodic();
}
