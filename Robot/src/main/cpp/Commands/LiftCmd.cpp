// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "Commands/LiftCmd.h"

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

LiftCmd::LiftCmd(): frc::Command() {
        // Use requires() here to declare subsystem dependencies
    // eg. requires(Robot::chassis.get());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	Requires(Robot::liftSubSystem.get());
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
}
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

// Called just before this Command runs the first time
void LiftCmd::Initialize()
{
    // initialize our local accessors
    controllerState = Robot::controllerState2.get();
    liftSubSystem = Robot::liftSubSystem.get();
    liftSubSystem->ZeroSensors();
    printf("Lift command initialized\n");
}

// Called repeatedly when this Command is scheduled to run
void LiftCmd::Execute()
{
    if (this->controllerState->GetButtonY())
    {
        printf("Sensors zeroed\n");
        this->liftSubSystem->ZeroSensors();
        this->controllerState->ForceButtonState(BUTTON_Y, false);
    }

    if (this->controllerState->m_controller.GetRawButton(BUMPER_LEFT))
    {
        // set closed loop mode for talons 5 & 7 (level lifting of robot)
        this->ClosedLoopExecute();
    }
    // else if (this->controllerState->GetRightTrig() > .5)
    // {
    //     // set 'auto' mode
    //     this->AutoExecute();
    // }
    else
    { 
        // set open loop mode for talons 5 & 7 (front & rear lift are separate)
        this->OpenLoopExecute();
    }
}

// Make this return true when this Command no longer needs to run execute()
bool LiftCmd::IsFinished()
{
    return false;
}

// Called once after isFinished returns true
void LiftCmd::End()
{
    this->liftSubSystem->StopMotors();
}

// Called when another command which requires one or more of the same
// subsystems is scheduled to run
void LiftCmd::Interrupted()
{
}

////// user defined methods ///////

void  LiftCmd::OpenLoopExecute()
{
    // rear motor speed from left joystick
    float rearMotorSpeed = -controllerState->GetRightY() * .5;

    // weaker front motor speed is linear with right joystick
    float frontMotorSpeed = controllerState->GetLeftY();

    // pass motor speeds to subsystem
    this->liftSubSystem->SetRearMotorSpeed(rearMotorSpeed);
    this->liftSubSystem->SetFrontMotorSpeed(frontMotorSpeed);

    // put the drive subsystem into manual open-loop mode
    Robot::liftMode = LiftMode::Manual;
}

void LiftCmd::ClosedLoopExecute()
{
    // set the left joystick Y value to manually drive the rear lift
    this->liftSubSystem->SetLeftJoystickY(this->controllerState->GetLeftY());

    // put the drive subsystem into manual closed loop level lift mode
    Robot::liftMode = LiftMode::Level;
}

void LiftCmd::AutoExecute()
{
    // if we aren't already retracting the front lift...
    if (Robot::liftMode != LiftMode::RetractFront)
    {
        // put the drive subsystem into auto closed loop level lift mode
        // this mode will automatically change to retract the front lift when finished
        Robot::liftMode = LiftMode::AutoLevel;
    }
}