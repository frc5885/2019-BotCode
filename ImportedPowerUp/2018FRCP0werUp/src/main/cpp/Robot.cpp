// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "Robot.h"
#include <iostream>
#include "Commands/AutoCrossLine.h"
#include "Commands/AutoSwitchScaleStraight.h"
#include "Commands/AutoSwitchScaleCross.h"

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INITIALIZATION
std::shared_ptr<DriveTrain> Robot::driveTrain;
std::shared_ptr<AircontrolModule> Robot::aircontrolModule;
std::shared_ptr<CubeIntake> Robot::cubeIntake;
std::shared_ptr<ScissorLift> Robot::scissorLift;
std::unique_ptr<OI> Robot::oi;


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INITIALIZATION

std::shared_ptr<frc::Joystick> xboxController;
std::unique_ptr<ControllerState> Robot::controllerState1;
std::unique_ptr<ControllerState> Robot::controllerState2;

// Parameters that apply to all autonomous commands
double Robot::autoLength = 38.5;
double Robot::autoWidth = 33.0;
double Robot::autoStraightMotorSpeed = 0.6;
double Robot::autoTurnMotorSpeed = 1.0;
double Robot::autoScissorMotorSpeed = 1.0;
double Robot::autoDwellTime = 1.0;

// longDistance is the distance before the first turn.
// shortDistance is the distance to the device after the turn.
// 1st array value is switch, 2nd array value is scale.
std::vector<double> Robot::longDistance;	// from field measurements!
std::vector<double> Robot::shortDistance;	// from field measurements!

std::vector<double> Robot::autoTurnAngle;			// calibrated encoder values for 90 deg.
std::vector<double> Robot::startSideTurnFactor;		// 1 for left, -1 for right

void Robot::RobotInit() {
	RobotMap::init();
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    driveTrain.reset(new DriveTrain());
    aircontrolModule.reset(new AircontrolModule());
    cubeIntake.reset(new CubeIntake());
    scissorLift.reset(new ScissorLift());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
	// This MUST be here. If the OI creates Commands (which it very likely
	// will), constructing it during the construction of CommandBase (from
	// which commands extend), subsystems are not guaranteed to be
	// yet. Thus, their requires() statements may grab null pointers. Bad
	// news. Don't move it.
	oi.reset(new OI());

	//These controller states are used instead of OI
	controllerState1.reset(new ControllerState(0));  //1st xbox controller for driving
	controllerState2.reset(new ControllerState(1));  //2nd xbox controller for subsystems


	// Add commands to Autonomous Sendable Chooser
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS
//	frc::SmartDashboard::PutData("Auto Modes", &chooser);

	//Adding all starting positions
	positionChooser.AddDefault("Center", "Center");
	positionChooser.AddObject("Left", "Left");
	positionChooser.AddObject("Right", "Right");

	//Adding all objectives
	objectiveChooser.AddDefault("Baseline", "Baseline");
	objectiveChooser.AddObject("Switch", "Switch");
	objectiveChooser.AddObject("Scale", "Scale");
	objectiveChooser.AddObject("Vault", "Vault");

	//Adding dwell options
	dwellChooser.AddDefault("None", 0.0);
	dwellChooser.AddObject("1: One Second", 1.0);
	dwellChooser.AddObject("3: Three Seconds", 3.0);
	dwellChooser.AddObject("5: Five Seconds", 5.0);
	dwellChooser.AddObject("7: Seven Seconds", 6.9);
	dwellChooser.AddObject("9: Nine Seconds", 9.0);

	//Putting on the smart dashboard
	frc::SmartDashboard::PutData("Positions", &positionChooser);
	frc::SmartDashboard::PutData("Objectives", &objectiveChooser);
	frc::SmartDashboard::PutData("DwellTime", &dwellChooser);


	xboxController = oi->getXboxController();

	// brake the scissor lift when turning it off!
	RobotMap::scissorLiftScissorLiftMotor->SetNeutralMode(Brake);

	//*************************************************************
	// field measurements
	// longDistance is the distance before the first turn.
	// shortDistance is the distance to the device after the turn.
	// 1st array value is switch, 2nd array value is scale.
	Robot::longDistance.push_back(168.0);	// [0]
	Robot::longDistance.push_back(318.0);	// [1]

	Robot::shortDistance.push_back(85.25);	// [0]
	Robot::shortDistance.push_back(71.57);	// [1]
	//*************************************************************

	// auto turn values
	Robot::autoTurnAngle.push_back(19.75);	// left
	Robot::autoTurnAngle.push_back(-18.75);	// right
	startSideTurnFactor.push_back(1.0);
	startSideTurnFactor.push_back(-1.0);
}

/**
 * This funoction is called when the disabled button is hit.
 * You can use it to reset subsystems before shutting down.
 */
void Robot::DisabledInit(){

}

void Robot::DisabledPeriodic() {
	frc::Scheduler::GetInstance()->Run();
}

void Robot::AutonomousInit()
{
	RobotMap::driveTrainDriverLeftFront->SetNeutralMode(Brake);
	RobotMap::driveTrainDriverLeftBack->SetNeutralMode(Brake);
	RobotMap::driveTrainDriverRightFront->SetNeutralMode(Brake);
	RobotMap::driveTrainDriverRightBack->SetNeutralMode(Brake);

	//Gets game specific message
	std::string gameData = frc::DriverStation::GetInstance().GetGameSpecificMessage();

	//Gets dwell option from smart dash board
	double dwellTime = dwellChooser.GetSelected();

	//Gets selected starting position from smart dash board
	std::string startingPosition = positionChooser.GetSelected();

	//gets target from smart dash board
	std::string target = objectiveChooser.GetSelected();

	if (target == "Baseline")
	{
		auto autoCommand = new AutoCrossLine(dwellTime);

		if (autoCommand != nullptr)
		{
			autoCommand->Start();
		}
	}
	else if (target == "Switch" || target == "Scale")
	{
		int switchOrScale = (target == "Switch") ? AUTO_SWITCH : AUTO_SCALE;

		if (gameData[0] == 'L')				// left switch/scale is active
		{
			if (startingPosition == "Left")	// we are starting on the left
			{
				auto autoCommand = new AutoSwitchScaleStraight(dwellTime, switchOrScale, AUTO_START_LEFT);

				if (autoCommand != nullptr)
				{
					autoCommand->Start();
				}
			}
			else							// we are starting on the right
			{
				auto autoCommand = new AutoSwitchScaleCross(dwellTime, switchOrScale, AUTO_START_RIGHT);

				if (autoCommand != nullptr)
				{
					autoCommand->Start();
				}
			}
		}
		else								// right switch/scale is active
		{
			if (startingPosition == "Left")	// we are starting on the left
			{
				auto autoCommand = new AutoSwitchScaleCross(dwellTime, switchOrScale, AUTO_START_LEFT);

				if (autoCommand != nullptr)
				{
					autoCommand->Start();
				}
			}
			else							// we are starting on the right
			{
				auto autoCommand = new AutoSwitchScaleStraight(dwellTime, switchOrScale, AUTO_START_RIGHT);

				if (autoCommand != nullptr)
				{
					autoCommand->Start();
				}
			}
		}
	}
}

void Robot::AutonomousPeriodic()
{
	frc::Scheduler::GetInstance()->Run();
}

void Robot::TeleopInit() {
	// This makes sure that the autonomous stops running when
	// teleop starts running. If you want the autonomous to
	// continue until interrupted by another command, remove
	// these lines or comment it out.
	RobotMap::driveTrainDriverLeftFront->SetNeutralMode(Brake);
	RobotMap::driveTrainDriverLeftBack->SetNeutralMode(Brake);
	RobotMap::driveTrainDriverRightFront->SetNeutralMode(Brake);
	RobotMap::driveTrainDriverRightBack->SetNeutralMode(Brake);

	if (autonomousCommand != nullptr)
	{
		autonomousCommand->Cancel();
	}

	teleopCommand = new(Teleoperation);

	if (teleopCommand != nullptr)
	{
		teleopCommand->Start();
	}
}

void Robot::TeleopPeriodic()
{
	controllerState1->GetState();
	controllerState2->GetState();
	frc::Scheduler::GetInstance()->Run();
}

void Robot::TestPeriodic()
{
	float distance = RobotMap::driveTrainWheelEncoder->GetDistance();
	printf("distance, %4.3f, rate, %4.3f\n", distance, RobotMap::driveTrainWheelEncoder->GetRate());

}

void Robot::alexAsked()
{
	float rightTrigger = xboxController->GetRawAxis(3);
		float leftTrigger = xboxController->GetRawAxis(2);


		if(rightTrigger > 0.2)
		{
//			singleMotor->motorOne->Set(rightTrigger);
		}
		else if(leftTrigger > 0.2)
		{
//			singleMotor->motorOne->Set(leftTrigger * -1);

			std::cout<< xboxController->GetRawButtonPressed(2) + "\n";
		}
		else
		{
//			singleMotor->motorOne->Set(0);
		}

		float leftBumper = xboxController->GetRawButton(6);
		float rightBumper = xboxController->GetRawButton(5);


		if(rightBumper)
		{
//			dualMotor->motorOne->Set(1);
//			dualMotor->motorTwo->Set(1);
		}
		else if(leftBumper)
		{
//			dualMotor->motorOne->Set(-1);
//			dualMotor->motorTwo->Set(-1);
		}
		else
		{
//			dualMotor->motorOne->Set(0);
//			dualMotor->motorTwo->Set(0);
		}
}

void Robot::PCMod()
{
	int pov = xboxController->GetPOV();

	if (pov == 0)
	{

//		RobotMap::pCModulecubeKicker->Set(DoubleSolenoid::Value::kForward);

	}
	else if (pov == 180)
	{
//		RobotMap::pCModulecubeKicker->Set(DoubleSolenoid::Value::kReverse);

	}
	else
	{
//		RobotMap::pCModulecubeKicker->Set(DoubleSolenoid::Value::kOff);
	}
}

START_ROBOT_CLASS(Robot);

