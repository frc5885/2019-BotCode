// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "RobotStraight.h"

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

RobotStraight::RobotStraight(double targetDistance, double motorSpeed): frc::Command() {
    m_targetDistance = targetDistance;
    m_motorSpeed = motorSpeed;
        // Use requires() here to declare subsystem dependencies
    // eg. requires(Robot::chassis.get());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
}
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

// Called just before this Command runs the first time
void RobotStraight::Initialize()
{
	RobotMap::driveTrainWheelEncoder->Reset();
	printf("Go forward initialized\n");
}

// Called repeatedly when this Command is scheduled to run
void RobotStraight::Execute()
{
	float distance = fabs(RobotMap::driveTrainWheelEncoder->GetDistance());
	float deltaDistance = m_targetDistance - distance;
	float kFactor = 0.006;
	float speed = kFactor * deltaDistance;

	if (fabs(speed) > m_motorSpeed)
	{
		speed = m_motorSpeed * SignOf(deltaDistance);
	}
	else if (fabs(speed) < 0.25)
	{
		speed = 0.25 * SignOf(deltaDistance);
	}

	printf("distance, %4.3f, rate, %4.3f\n", distance, RobotMap::driveTrainWheelEncoder->GetRate());
//	RobotMap::driveTrainDriverRightFront->Set(-speed);
	RobotMap::driveTrainDriverLeft->Set(speed);
	RobotMap::driveTrainDriverRight->Set(-speed);
//	RobotMap::driveTrainDriverLeftBack->Set(speed);

	char numStr[80] = "";

	sprintf(numStr, "%4.3f", RobotMap::driveTrainDriverLeftFront->GetOutputCurrent());
	SmartDashboard::PutString("DB/String 0", numStr);
	sprintf(numStr, "%4.3f", RobotMap::driveTrainDriverLeftBack->GetOutputCurrent());
	SmartDashboard::PutString("DB/String 1", numStr);
	sprintf(numStr, "%4.3f", RobotMap::driveTrainDriverRightFront->GetOutputCurrent());
	SmartDashboard::PutString("DB/String 5", numStr);
	sprintf(numStr, "%4.3f", RobotMap::driveTrainDriverRightBack->GetOutputCurrent());
	SmartDashboard::PutString("DB/String 6", numStr);
}

// Make this return true when this Command no longer needs to run execute()
bool RobotStraight::IsFinished()
{
	float distance = fabs(RobotMap::driveTrainWheelEncoder->GetDistance());
	frc::SmartDashboard::PutNumber("Distance", distance);
	float deltaDistance = fabs(m_targetDistance - distance);
	bool finished = (deltaDistance < 0.5 &&
			fabs(RobotMap::driveTrainWheelEncoder->GetRate()) < 10.0);

	if (finished)
	{
		printf("GoForward is finished\n");
	}
    return finished;
}

// Called once after isFinished returns true
void RobotStraight::End()
{
	RobotMap::driveTrainDriverRightFront->StopMotor();
	RobotMap::driveTrainDriverLeftFront->StopMotor();
	RobotMap::driveTrainDriverRightBack->StopMotor();
	RobotMap::driveTrainDriverLeftBack->StopMotor();
	printf("Go forward ended\n");
//	Robot::driveTrain->driverRight->Set(0.0);
//	Robot::driveTrain->driverLeft->Set(0.0);
}

// Called when another command which requires one or more of the same
// subsystems is scheduled to run
void RobotStraight::Interrupted() {

}
