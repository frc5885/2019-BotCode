// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "TankDrive.h"

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

TankDrive::TankDrive(): frc::Command() {
        // Use requires() here to declare subsystem dependencies
    // eg. requires(Robot::chassis.get());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	Requires(Robot::driveTrain.get());
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
}
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

// Called just before this Command runs the first time
void TankDrive::Initialize() {

}

// Called repeatedly when this Command is scheduled to run
void TankDrive::Execute()
{
	// get raw joystick values and +- sign
	//this pulls the joystick values into the program.
	//(gets the state) gets what you want to do
	float leftX = -Robot::controllerState1->GetLeftY();
	float rightX = -Robot::controllerState1->GetRightY();

	//if the joystick values are almost the same, make them the same to make driving straight easier.
//	if (Equals(leftX, rightX, .2)) // Threshold value was changed to correct an issue.
//		//The issue was that slight input on the right stick would stop or slow down the input on the left side, and vice versa.
//	{
//		rightX = leftX;
//	}

	// compute the adjusted motor values based n joystick / motor curve
	//this takes the value and matches it with the closest value on our parabola
	//so that the driving is smoother
	float leftY = SignOf(leftX) * SmoothDriveCurve(fabs(leftX));
	float rightY = SignOf(rightX) * SmoothDriveCurve(fabs(rightX));

	if (Robot::controllerState1->GetButtonA()) // Invert drive code
	{
		SmartDashboard::PutString("DB/String 3", "Front: Intake");
		float temp = leftY;
		leftY = rightY;
		rightY = temp;
	}
	else
	{
		SmartDashboard::PutString("DB/String 3", "Front: Scoop");
	}

	// motor gain value - used to slow down drive system for new drivers
	// always >= .4 and <= 1.0!!!
	// Turbo mode
	double gain = (Robot::controllerState1->GetRightTrig() > 0.2 ? 1.0 : 0.6);

	Robot::driveTrain->driverLeftFront->Set(gain * leftY);
	Robot::driveTrain->driverLeftBack->Set(gain * leftY);
	Robot::driveTrain->driverRightFront->Set(gain * rightY);
	Robot::driveTrain->driverRightBack->Set(gain * rightY);

	char numStr[80] = "";

	sprintf(numStr, "%4.3f", leftX);
	SmartDashboard::PutString("DB/String 0", numStr);
	sprintf(numStr, "%4.3f", gain * leftY);
	SmartDashboard::PutString("DB/String 1", numStr);
	sprintf(numStr, "%4.3f", Robot::driveTrain->driverLeft->Get());
	SmartDashboard::PutString("DB/String 2", numStr);
	sprintf(numStr, "%4.3f", rightX);
	SmartDashboard::PutString("DB/String 5", numStr);
	sprintf(numStr, "%4.3f", gain * rightY);
	SmartDashboard::PutString("DB/String 6", numStr);
	sprintf(numStr, "%4.3f", Robot::driveTrain->driverRight->Get());
	SmartDashboard::PutString("DB/String 7", numStr);
//	printf("Left Joystick:%4.3f Speed:%4.3f  Right Joystick:%4.3f Speed:%4.3f\n",
//			leftJoystickYAxis, Robot::driveTrain->driverLeft->Get(),
//			rightJoystickYAxis, Robot::driveTrain->driverRight->Get());
}

// Make this return true when this Command no longer needs to run execute()
bool TankDrive::IsFinished() {
    return false;
}

// Called once after isFinished returns true
void TankDrive::End()
{
	//Robot::driveTrain->driverRight->Set(0);
	//Robot::driveTrain->driverLeft->Set(0);
}

// Called when another command which requires one or more of the same
// subsystems is scheduled to run
void TankDrive::Interrupted() {

}

double TankDrive::SmoothDriveCurve(double joystickYPosition)
{
	if (joystickYPosition < .05)
	{
		return 0.0;		// allow for joystick calibration error
	}

	// data points on drive curve parabola
	double x2 = .5, y2 = .5, y3 = 1.0;

	// variable a=a in equation b=b in equation
	//ax^2+bx+c the Equation for a parabola
	double b = ((y3 * x2 * x2) - y2) / ((x2 * x2) - x2);
	double a = y3 - b;

	// Returns the corresponding motor speed
	return (a * joystickYPosition * joystickYPosition) + (b * joystickYPosition);
}
