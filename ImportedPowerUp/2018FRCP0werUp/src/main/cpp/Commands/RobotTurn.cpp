// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

#include "RobotTurn.h"

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

RobotTurn::RobotTurn(int leftOrRight, double motorSpeed): frc::Command()
{
	m_curAngle = 0.0;
	m_curTurnRate = 0.0;
    m_leftOrRight = leftOrRight;
    m_motorSpeed = motorSpeed;
    m_targetAngle = Robot::autoTurnAngle[leftOrRight];
        // Use requires() here to declare subsystem dependencies
    // eg. requires(Robot::chassis.get());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
}
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

// Called just before this Command runs the first time
void RobotTurn::Initialize()
{
	RobotMap::driveTrainWheelEncoder->Reset();
	m_targetAngle = Robot::autoTurnAngle[m_leftOrRight];
	m_curAngle = 0.0;
	m_curTurnRate = 0.0;
}

// Called repeatedly when this Command is scheduled to run
void RobotTurn::Execute()
{
	m_curAngle = RobotMap::driveTrainWheelEncoder->GetDistance();
	m_curTurnRate = RobotMap::driveTrainWheelEncoder->GetRate();
	float deltaAngle = m_targetAngle - m_curAngle;
	float kFactor = -.7;		// always negative!!!
	float speed = deltaAngle * kFactor;

	if (fabs(speed) > m_motorSpeed)
	{
		speed = m_motorSpeed * SignOf(speed);	// Preserve the motor direction!
	}
	else if (fabs(speed) < 0.1)
	{
		speed = 0.1 * SignOf(speed);			// Preserve the motor direction!
	}


//	frc::SmartDashboard::PutNumber("Angle", m_curAngle);

	printf("angle = %4.3f   tangle = %4.3f  dangle = %4.3f rate = %4.3f   motor speed = %4.3f \n", m_curAngle, m_targetAngle, deltaAngle, m_curTurnRate, speed);
	Robot::driveTrain->driverRight->Set(speed);
	Robot::driveTrain->driverLeft->Set(speed);
	//Robot::driveTrain->driverRightFront->Set(speed);
	//Robot::driveTrain->driverLeftBack->Set(speed);
}

// Make this return true when this Command no longer needs to run execute()
bool RobotTurn::IsFinished()
{
    bool finished = (fabs(m_curAngle - m_targetAngle) < 0.5) &&
    		fabs(m_curTurnRate) < 10.0;

	return finished;
}

// Called once after isFinished returns true
void RobotTurn::End()
{
	Robot::driveTrain->driverRight->Set(0.0);
	Robot::driveTrain->driverLeft->Set(0.0);
}

// Called when another command which requires one or more of the same
// subsystems is scheduled to run
void RobotTurn::Interrupted() {

}
